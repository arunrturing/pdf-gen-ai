import PDFDocument from 'pdfkit';
import fs from 'fs';
import path from 'path';
import axios from 'axios';
import { Buffer } from 'buffer';
import sizeOf from 'image-size';

// Constants for layout configuration
const MARGIN = 50;
const PAGE_WIDTH = 595.28; // A4 width in points
const LOGO_MAX_WIDTH = 150;
const LOGO_MAX_HEIGHT = 80;
const COMPANY_NAME_FONT_SIZE = 16;
const PARAGRAPH_FONT_SIZE = 12;
const DEFAULT_FONT = 'Helvetica';
const DEFAULT_FONT_COLOR = '#000000';

// Define the type for PDF content items
interface PdfContentItem {
  attributeType: 'paragraph' | 'signature' | 'designation';
  content: string;
}

// Define options interface
interface PdfOptions {
  outputPath?: string;
  title?: string;
  subject?: string;
  author?: string;
  keywords?: string[];
}

/**
 * Creates a PDF with logo, company name, and content items
 * @param logoUrl - URL or file path to the logo
 * @param companyName - Name of the company to display in the header
 * @param pdfData - Array of content items to include in the PDF
 * @param options - Optional settings for PDF generation
 * @returns Promise resolving to the path of the created PDF file
 */
export async function createPdf(
  logoUrl: string,
  companyName: string,
  pdfData: PdfContentItem[],
  options?: PdfOptions
): Promise<string> {
  // Default options
  const outputPath = options?.outputPath || `./output/document-${Date.now()}.pdf`;
  const outputDir = path.dirname(outputPath);
  
  // Ensure output directory exists
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Create a new PDF document
  const doc = new PDFDocument({
    size: 'A4',
    margin: MARGIN,
    info: {
      Title: options?.title || 'Generated Document',
      Subject: options?.subject || 'Generated by PDF Generator',
      Author: options?.author || 'PDF Generator',
      Keywords: options?.keywords?.join(', ') || ''
    }
  });

  // Create a write stream for the output file
  const outputStream = fs.createWriteStream(outputPath);
  doc.pipe(outputStream);

  try {
    // Header with logo and company name
    let headerHeight = MARGIN;
    
    // Load and position the logo
    const logoResult = await fetchLogo(logoUrl);
    
    if (logoResult && logoResult.buffer) {
      // Get dimensions of the image using image-size
      let logoWidth = logoResult.dimensions?.width || LOGO_MAX_WIDTH;
      let logoHeight = logoResult.dimensions?.height || LOGO_MAX_HEIGHT;
      
      // Scale down if necessary
      if (logoWidth > LOGO_MAX_WIDTH) {
        const ratio = LOGO_MAX_WIDTH / logoWidth;
        logoWidth = LOGO_MAX_WIDTH;
        logoHeight = Math.floor(logoHeight * ratio);
      }
      
      if (logoHeight > LOGO_MAX_HEIGHT) {
        const ratio = LOGO_MAX_HEIGHT / logoHeight;
        logoHeight = LOGO_MAX_HEIGHT;
        logoWidth = Math.floor(logoWidth * ratio);
      }
      
      // Draw the logo at the top left
      doc.image(logoResult.buffer, MARGIN, MARGIN, {
        width: logoWidth,
        height: logoHeight
      });
      
      headerHeight = MARGIN + logoHeight + 20; // Add some space below the logo
      
      // Position company name at the top right
      doc.font(`${DEFAULT_FONT}-Bold`)
        .fontSize(COMPANY_NAME_FONT_SIZE)
        .fillColor(DEFAULT_FONT_COLOR)
        .text(companyName, 
              PAGE_WIDTH - MARGIN - doc.widthOfString(companyName), 
              MARGIN + (logoHeight / 2) - (COMPANY_NAME_FONT_SIZE / 2), // Center vertically with logo
              { align: 'right' });
    } else {
      // If logo loading failed, put the company name centered at the top
      doc.font(`${DEFAULT_FONT}-Bold`)
        .fontSize(COMPANY_NAME_FONT_SIZE)
        .fillColor(DEFAULT_FONT_COLOR)
        .text(companyName, { align: 'center' });
      
      headerHeight = MARGIN + COMPANY_NAME_FONT_SIZE + 20;
    }
    
    // Move to below the header
    doc.y = headerHeight;
    
    // Add content based on attributeType
    if (pdfData && pdfData.length > 0) {
      for (const item of pdfData) {
        switch (item.attributeType) {
          case 'paragraph':
            doc.font(DEFAULT_FONT)
              .fontSize(PARAGRAPH_FONT_SIZE)
              .fillColor(DEFAULT_FONT_COLOR)
              .text(item.content, {
                align: 'justify',
                lineGap: 5
              });
            doc.moveDown();
            break;
            
          case 'signature':
            doc.font('Helvetica-Oblique')
              .fontSize(PARAGRAPH_FONT_SIZE)
              .fillColor(DEFAULT_FONT_COLOR)
              .text(item.content, {
                align: 'right'
              });
            doc.moveDown(0.5);
            break;
            
          case 'designation':
            doc.font(`${DEFAULT_FONT}-Bold`)
              .fontSize(PARAGRAPH_FONT_SIZE - 2) // Slightly smaller
              .fillColor(DEFAULT_FONT_COLOR)
              .text(item.content, {
                align: 'right'
              });
            doc.moveDown();
            break;
        }
      }
    } else {
      // Add default content to avoid blank page
      doc.font(DEFAULT_FONT)
        .fontSize(PARAGRAPH_FONT_SIZE)
        .fillColor(DEFAULT_FONT_COLOR)
        .text('No content provided for this document.', {
          align: 'center'
        });
    }
    
    // Finalize the PDF
    doc.end();
    
    // Return a promise that resolves when the PDF has been fully written
    return new Promise<string>((resolve, reject) => {
      outputStream.on('finish', () => resolve(outputPath));
      outputStream.on('error', reject);
    });
    
  } catch (error) {
    // Ensure document is ended even if there's an error
    doc.end();
    throw new Error(`Error creating PDF: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Result of logo fetch operation
 */
interface LogoResult {
  buffer: Buffer | null;
  dimensions?: { width: number; height: number };
}

/**
 * Fetches a logo from a URL or local file path
 * @param logoUrl - URL or file path to the logo
 * @returns Promise resolving to a LogoResult containing the image buffer and dimensions
 */
async function fetchLogo(logoUrl: string): Promise<LogoResult | null> {
  try {
    let imageBuffer: Buffer | null = null;
    
    // Check if the logo URL is a remote URL
    if (logoUrl.startsWith('http://') || logoUrl.startsWith('https://')) {
      // Fetch remote image using axios
      const response = await axios.get(logoUrl, {
        responseType: 'arraybuffer',
        timeout: 5000 // Set a timeout for the request
      });
      imageBuffer = Buffer.from(response.data);
    } else if (fs.existsSync(logoUrl)) {
      // Read local file
      imageBuffer = fs.readFileSync(logoUrl);
    } else {
      console.warn(`Logo file not found: ${logoUrl}`);
      return null;
    }
    
    if (!imageBuffer) return null;
    
    // Get image dimensions using image-size
    try {
      const dimensions = sizeOf(imageBuffer);
      return {
        buffer: imageBuffer,
        dimensions: {
          width: dimensions.width || LOGO_MAX_WIDTH,
          height: dimensions.height || LOGO_MAX_HEIGHT
        }
      };
    } catch (err) {
      // If we can't determine image dimensions, return the buffer with default dimensions
      return {
        buffer: imageBuffer,
        dimensions: {
          width: LOGO_MAX_WIDTH,
          height: LOGO_MAX_HEIGHT
        }
      };
    }
  } catch (error) {
    console.error(`Error loading logo: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}